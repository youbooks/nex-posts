# MySQL的锁

  为什么MySQL要加锁呢？OLTP数据库离不开事务，事务也离不开并发操作下一致性的问题。现代数据库解决事务的并发控制有两种办法，2PL和MVCC[1]。
  2PL是加锁方案的代表，就是将数据操作分为加锁和解锁两个阶段，任何数据操作都会将访问对象加上锁，后续对这个对象的数据操作就会被阻塞直到锁释放（事务提交）。传统数据库大都是用2PL来实现并发控制的。
  MVCC(多版本并发控制)是无锁方案的代表，通过对数据库每一次变更记录版本快照，实现读-写互不阻塞，写-写是否阻塞取决于具体实现（例如postgres的SERIALIZABLE级别下写-写互不阻塞，发生冲突抛出异常）。
  对于MySQL(innoDB)来说，是通过MVCC实现读-写并发控制，又是通过2PL写-写并发控制的，因此依然保留着(悲观)锁这个概念，既然有悲观锁，自然就有可能产生死锁问题。
  MySQL的事务我之前在这篇文章里做过一些粗浅的理解：[传送门](http://fanyilun.me/2015/12/29/%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%BB%A5%E5%8F%8AMysql%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%BD%BF%E7%94%A8/) （痛心的是网上大部分资料还是显示mySql在RR隔离级别下会幻读。。）

那么MySQL会如何加锁呢[2]：

MySQL锁的模式：

- 共享/排它锁

   

  (S锁/X锁) (Shared and Exclusive Locks)

  - S锁与X锁冲突，S锁与S锁不冲突，X锁和X锁冲突
    - 锁冲突意味着无法获取锁的事务需要等待，锁被释放后才能继续。当然也有可能等待超时或检测出死锁
  - 快照读(普通select …)不加锁
  - select..lock in share mode / Serializable下的select 会加S锁
  - select..for update / 写操作(insert update delete) 会加X锁
  - 上述的锁都是行级别的，S锁和X锁同样可以加在表级别上，对应的语句分别是LOCK TABLE … READ和LOCK TABLE … WRITE

- 意向锁

   

  (IS锁/IX锁) (Intention Locks)

  - 意向锁是**表级别**的锁，用来标识该表上面有数据被锁住（或即将被锁）
  - 一个事务在获取（任何一行/或者全表）S锁之前，一定会先在所在的表上加IS锁。同理，获取X锁之前一定会加上IX锁。
  - 意向锁提出的目的，就是要标识这个表上面有锁，这样一来，对于表级别锁的请求（LOCK TABLE …），就可以直接判断是否有锁冲突，而不需要逐行检查锁的状态了。从更大的角度来看，意向锁就是为了实现不同粒度的锁共存，每次加锁都需要先对上面更粗粒度的数据结构加意向锁，用来表达“这个数据结构中存在被锁住的数据”。

其兼容矩阵如下（+表示兼容，-表示冲突）：

| \    | IS   | IX   | S    | X    |
| ---- | ---- | ---- | ---- | ---- |
| IS   | +    | +    | +    | –    |
| IX   | +    | +    | –    | –    |
| S    | +    | –    | +    | –    |
| X    | –    | –    | –    | –    |

  上面提到的锁的模式，指的是如何锁住数据，各种模式之间是否兼容；下面提到的锁的类型，定义的是具体锁在哪里。二者并不冲突，比如record lock可以分成record x lock和record s lock。

MySQL锁的类型：

- Record Locks
  - 对单条索引记录上加的锁。准确的说，锁是加在索引上的而非行上。因为innodb一定会有一个聚簇索引，因此最终的行锁都会落到聚簇索引上。
  - 可以加在聚簇索引或者二级索引上。
- Gap Locks
  - gap lock是对索引间隙加的锁，可以是在一条索引记录之前，也可以在一条索引记录之后。
  - gap lock的唯一作用，就是阻止其他事务向锁住的gap里插入数据。
  - gap lock下的所有锁的模式都是兼容的，比如同一个位置的gap s lock和gap x lock是可以共存的。其作用也是完全相同的。
  - 在READ COMMITTED隔离级别下，不会使用gap lock。因此下文关于gap lock的加锁，对于RC隔离级别可以自动忽略。
- Next-Key Locks
  - Next-Key lock与record lock加锁的粒度一样，都是加在一条索引记录上的。一个next-key lock=对应的索引记录的record lock+该索引**前面的**间隙的gap lock
  - 虽然说Next-Key Lock代表着record lock+前一个间隙的gap lock，在必要的情况下，最后一条记录后面的gap也有可能作为一条单独的gap lock被锁住[3]。
  - 由于锁住的是前面的间隙，所以有些资料也会用左开右闭的区间来表示next-key lock，例如(1,3]
- Insert Intention Locks
  - Insert Intention Lock是一种特殊的间隙锁，执行insert之前会向插入的间隙加上Insert Intention Lock
  - Insert Intention Lock与已有的gap lock冲突，因此gap lock锁住的间隙是不能插入数据的
  - Insert Intention Lock与Insert Intention Lock之间不冲突，因此允许了同时向同一个间隙插入不同主键的数据

其兼容矩阵如下，+表示兼容，-表示冲突：

| 要加的锁\ 已存在的锁  | record lock | gap lock | insert intention lock | next key lock |
| --------------------- | ----------- | -------- | --------------------- | ------------- |
| record lock           | –           | +        | +                     | –             |
| gap lock              | +           | +        | +                     | +             |
| insert intention lock | +           | –        | +                     | –             |
| next key lock         | –           | +        | +                     | –             |

## 实验

以下实验数据基于MySQL 5.7。
假设已知一张表my_table，id列为主键。

| id   | name | num  |
| ---- | ---- | ---- |
| 1    | aaa  | 100  |
| 5    | bbb  | 200  |
| 8    | bbb  | 300  |
| 10   | ccc  | 400  |

对该表进行读写操作，可能产生的加锁情况如下（仅考虑隔离级别为RR和RC）：



## 1. 查询命中聚簇索引（主键索引）

1.1 如果是精确查询，那么会在命中的索引上加record lock。
例如：

```
// 在id=1的聚簇索引上加X锁
update my_table set name='a' where id=1;  

// 在id=1的聚簇索引上加S锁
select * from my_table where id=1 lock in share mode;
```

1.2 如果是范围查询，那么

- 1.2.1 在RC隔离级别下，会在所有命中的行的聚簇索引上加record locks（只锁行）

```
// 在id=8和10的聚簇索引上加X锁
update my_table set name='a' where id>7;  

// 在id=1的聚簇索引上加X锁
update my_table set name='a' where id<=1;
```

- 1.2.2 在RR隔离级别下，会在所有命中的行的聚簇索引上加next-key locks（锁住行和间隙）。最后命中的索引的后一条记录，也会被加上next-key lock。

```
// 在id=8、10(、+∞)的聚簇索引上加X锁
// 在(5,8)(8,10)(10,+∞)加gap lock
update my_table set name='a' where id>7;  

// 在id=1、5的聚簇索引上加X锁
// 在(-∞,1)(1,5)加gap lock
update my_table set name='a' where id<=1;
```

1.3 如果查询结果为空，那么

- 1.2.1 在RC隔离级别下，什么也不会锁
- 1.2.2 在RR隔离级别下，会锁住查询目标所在的间隙。

```
// 在(1,5)加gap lock
update my_table set name='a' where id=2;
```



## 2. 查询命中唯一索引

*假设上述表中，num列加了唯一索引*
2.1 如果是精确查询，那么会在命中的唯一索引，和对应的聚簇索引上加record lock。

```
// 在num=100的唯一索引上加X锁
// 并在id=1的聚簇索引上加X锁
update my_table set name='a' where num=100;
```

2.2 如果是范围查询，那么

- 2.2.1 在RC隔离级别下，会在所有命中的唯一索引和聚簇索引上加record lock。同2.1
- 2.2.2 在RR隔离级别下，会在所有命中的行的唯一索引上加next-key locks。最后命中的索引的后一条记录，也会被加上next-key lock。

```
// 在num=100和num=200的唯一索引上加X锁
// 并在id=1和id=5的聚簇索引上加X锁
// 并在唯一索引的间隙(-∞,100)(100,200)加gap lock
update my_table set name='a' where num<150;
```

2.3 如果查询结果为空，同1.3。唯一差别在于，此时加的gap lock是位于唯一索引上的。



## 3. 查询命中二级索引（非唯一索引）

*假设上述表中，name列加了普通二级索引，num列没有索引*
3.1 如果是精确查询，那么

- 3.1.1 在RC隔离级别下，同2.1，对命中的二级索引和聚簇索引加record lock

```
// 在name='bbb'的两条索引记录上加X锁
// 并在id=5和id=8的聚簇索引上加X锁
update my_table set num=10 where name='bbb';
```

- 3.1.2 在RR隔离级别下，会在命中的二级索引上加next-key lock，最后命中的索引的后面的间隙会加上gap lock。对应的聚簇索引上加record lock。

```
// 在name='bbb'的两条索引记录上加X锁
// 并在id=5和id=8的聚簇索引上加X锁
// 并在二级索引的间隙('aaa','bbb')('bbb','bbb')('bbb','ccc')加gap lock
update my_table set num=10 where name='bbb';
```

3.2 范围查询、模糊查询的情况比较复杂，此处不详述。可以用上述方法自己实验。



## 4. 查询没有命中索引

*假设上述表中，name列加了普通二级索引，num列没有索引*
4.1 如果查询条件没有命中索引

- 4.1.1 在RC隔离级别下，对命中的数据的聚簇索引加X锁。根据MySQL官方手册[4]，对于update和delete操作，RC只会锁住真正执行了写操作的记录，这是因为尽管innodb会锁住所有记录，MySQL Server层会进行过滤并把不符合条件的锁当即释放掉[5]。同时对于UPDATE语句，如果出现了锁冲突（要加锁的记录上已经有锁），innodb不会立即锁等待，而是执行semi-consistent read：返回改数据上一次提交的快照版本，供MySQL Server层判断是否命中，如果命中了才会交给innodb锁等待。因此加锁情况可以这样来认为：

```sql
// 在id=5的聚簇索引上加X锁
update my_table set num=1 where num=200;    

// 先在id=1,5,8,10（全表所有记录）的聚簇索引上加X锁
// 然后马上释放id=1,8,10的锁，只保留id=5的锁
delete from my_table where num=200;
```

- 4.1.2 在RR隔离级别下，事情就很糟糕了，对全表的所有聚簇索引数据加next-key lock

```sql
// 在id=1,5,8,10（全表所有记录）的聚簇索引上加X锁
// 并在聚簇索引的所有间隙(-∞,1)(1,5)(5,8)(8,10)(10,+∞)加gap lock
update my_table set num=100 where num=200;    

// 尽管name列有索引，但是like '%%'查询不使用索引，因此此时也是锁住所有聚簇索引，情况和上面一模一样
update my_table set num=100 where name like '%b%';
```



## 5. 对索引键值有修改

*假设上述表中，num列加了二级索引*
  如果一条update语句，对索引键值有修改，那么修改前后的数据如何加锁呢。这点要结合数据多版本的可见性来考虑：无论是聚簇索引，还是二级索引，只要其键值更新，就会产生新版本。将老版本数据deleted bti设置为1；同时插入新版本[6]。因此可以认为，一次索引键值的修改实际上操作了两条索引数据：原索引和修改后的新索引。
  从innodb的事务的角度来看，如果一个事务操作（写）了一条数据，那么这条数据一定要加锁。因此可以认为，**如果修改了索引键值，那么修改前和修改后的索引都会加锁**。另外，由于修改的数据并没有被作为查询条件，那么也不会有“不可重复读”和“幻读”的问题，因此无需加gap lock，索引修改只会加X record lock。



# 一个RC隔离级别下的死锁

  其实可以看到，RC隔离级别下的加锁已经很少了，用官方文档的话说”greatly reduces the probability of deadlocks”。因此尽管MySQL的默认隔离级别是RR，但是互联网应用更倾向与使用RC来避免死锁+提高并发能力。例如阿里电商的MySQL默认级别就是RC。
  尴尬的是，但是我也的的确确碰到了RC的死锁。还是以这个表来举例，假设id为主键，num列无索引。

| id   | name | num  |
| ---- | ---- | ---- |
| 1    | aaa  | 100  |
| 5    | bbb  | 200  |
| 8    | bbb  | 300  |

按以下顺序执行事务：

| trx1                                                         | trx2                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| insert into my_table (id, name, num) values (‘16’, ‘rrr’, ‘888’); | -                                                            |
| -                                                            | insert into my_table (id, name, num) values (‘17’, ‘ttt’, ‘999’); |
| delete from sys.my_table where num=300; // waiting           | -                                                            |
| -                                                            | delete from sys.my_table where num=400; // deadlock          |

  对照上文的加锁逻辑，insert会对聚簇索引加X锁，因此trx1和trx2首先会分别持有id=16和id=17的X锁。
  接下来坑爹的事情来了，对于无索引字段，delete操作不会执行semi-consistent read，而是先直接锁住所有数据的聚簇索引（尽管后面会马上释放，但也需要先获取锁）。这样一来，事务1的delete需要锁住所有记录，等待事务2持有的id=17的X锁，而事务2的delete需要等待事务1的id=16的X锁。死锁就产生了。
  在这个例子中，如果insert和delete的顺序都颠倒一下，或者delete都变为update，死锁都不会发生。







# 小结

- 索引记录的间隙上用来避免幻读。
- Select（Serializable隔离级别除外）不会加锁，而是执行快照读。
- 写操作都会加锁，具体加锁方式取决于隔离级别、索引命中情况以及修改的索引情况。
- 为了减少锁的范围，避免死锁的发生，应该尽量让查询条件命中索引，而且命中的越精确加锁越少。同时如果能接受RC级别对一致性的破坏，可以将隔离级别调整成RC。