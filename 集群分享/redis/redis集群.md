## 1. redis cluster介绍

Redis集群搭建的方式有多种，例如使用zookeeper等，但从redis 3.0之后版本支持redis-cluster集群，Redis-Cluster采用无中心结构，每个节点保存数据和整个集群状态,每个节点都和其他所有 节点连接。其redis-cluster架构图如下：

其结构特点：

​     1、所有的redis节点彼此互联(PING-PONG机制),内部使用二进制协议优化传输速度和带宽。
     2、节点的fail是通过集群中超过半数的节点检测失效时才生效。
     3、客户端与redis节点直连,不需要中间proxy层.客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可。
     4、redis-cluster把所有的物理节点映射到[0-16383]slot上（不一定是平均分配）,cluster 负责维护node<->slot<->value。

​     5、Redis集群预分好16384个桶，当需要在 Redis 集群中放置一个 key-value 时，根据 CRC16(key) mod 16384的值，决定将一个key放到哪个桶中。

(https://baike.baidu.com/item/CRC%E6%A0%A1%E9%AA%8C/3439037)

  现在我们是三个主节点分别是：A, B, C 三个节点，它们可以是一台机器上的三个端口，也可以是三台不同的服务器。那么，采用哈希槽 (hash slot)的方式来分配16384个slot 的话，它们三个节点分别承担的slot 区间是：
      节点A覆盖0－5460;
      节点B覆盖5461－10922;
      节点C覆盖10923－16383.

​     获取数据：

​      如果存入一个值，按照redis cluster哈希槽的算法： CRC16(key) mod 16384 = 6782。 那么就会把这个key 的存储分配到 B 上了。同样，当我连接(A,B,C)任何一个节点想获取'key'这个key时，也会这样的算法，然后内部跳转到B节点上获取数据 

​      新增一个节点D，redis cluster的这种做法是从各个节点的前面各拿取一部分slot到D上，我会在接下来的实践中实验。大致就会变成这样：

​    节点A覆盖1365-5460
    节点B覆盖6827-10922
    节点C覆盖12288-16383
    节点D覆盖0-1364,5461-6826,10923-12287
     同样删除一个节点也是类似，移动完成后就可以删除这个节点了。



## 2.failover

请看演示



## 3.主从数据保持一致性的方法

![mage-20180412095227](/var/folders/hr/c1f08q_n0msf4gp05cdnc04c0000gn/T/abnerworks.Typora/image-201804120952270.png)

####Redis复制工作原理的总结如下：

1.  如果设置了一个Slave，无论是第一次连接还是重连到Master，它都会发出一个SYNC命令；
2.  当Master收到SYNC命令之后，会做两件事：

​    a) Master执行BGSAVE，即在后台保存数据到磁盘（rdb快照文件）

​    b) Master同时将新收到的写入和修改数据集的命令存入缓冲区（非查询类）

3. 当Master在后台把数据保存到快照文件完成之后，Master会把这个快照文件传送给Slave，而Slave则把内存清空后，加载该文件到内存中；
4. 而Master也会把此前收集到缓冲区中的命令，通过Reids命令协议形式转发给Slave，Slave执行这些命令，实现和Master的同步；
5. Master/Slave此后会不断通过异步方式进行命令的同步，达到最终数据的同步一致；
6. 需要注意的是Master和Slave之间一旦发生重连都会引发全量同步操作。但在2.8之后版本，也可能是部分同步操作。

####部分复制

2.8开始，当Master和Slave之间的连接断开之后，他们之间可以采用持续复制处理方式代替采用全量同步。

Master端为复制流维护一个内存缓冲区（in-memory backlog），记录最近发送的复制流命令；同时，Master和Slave之间都维护一个复制偏移量(replication offset)和当前Master服务器ID（Masterrun id）。当网络断开，Slave尝试重连时：

​	a. 如果MasterID相同（即仍是断网前的Master服务器），并且从断开时到当前时刻的历史命令依然在Master的内存缓冲区中存在，则Master会将缺失的这段时间的所有命令发送给Slave执行，然后复制工作就可以继续执行了；

​	b. 否则，依然需要全量复制操作；

Redis 2.8 的这个部分重同步特性会用到一个新增的**PSYNC** 内部命令， 而 Redis 2.8 以前的旧版本只有 SYNC 命令， 不过， 只要从服务器是 Redis 2.8 或以上的版本，它就会根据主服务器的版本来决定到底是使用 PSYNC 还是 SYNC ：如果主服务器是 Redis 2.8 或以上版本，那么从服务器使用 PSYNC 命令来进行同步；如果主服务器是 Redis 2.8 之前的版本，那么从服务器使用 SYNC 命令来进行同步。