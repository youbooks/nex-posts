## 什么是paxos协议？

Paxos用于解决分布式系统中一致性问题。分布式一致性算法（Consensus Algorithm）是一个分布式计算领域的基础性问题，其最基本的功能是为了在多个进程之间对某个（某些）值达成一致（强一致）；简单来说就是确定一个值，一旦被写入就不可改变。paxos用来实现多节点写入来完成一件事情，例如mysql主从也是一种方案，但这种方案有个致命的缺陷，如果主库挂了会直接影响业务，导致业务不可写，从而影响整个系统的高可用性。paxos协议是只是一个协议，不是具体的一套解决方案。目的是解决多节点写入问题。

paxos协议用来解决的问题可以用一句话来简化：

> 将所有节点都写入同一个值，且被写入后不再更改。

## paxos的几个基本概念

**一、两个操作：**

1. Proposal Value：提议的值；
2. Proposal Number：提议编号，可理解为提议版本号，要求不能冲突；

**二、三个角色：**

1. Proposer：提议发起者。Proposer 可以有多个，Proposer 提出议案（value）。所谓 value，可以是任何操作，比如“设置某个变量的值为value”。不同的 Proposer 可以提出不同的 value，例如某个Proposer 提议“将变量 X 设置为 1”，另一个 Proposer 提议“将变量 X 设置为 2”，但对同一轮 Paxos过程，最多只有一个 value 被批准。
2. Acceptor：提议接受者；Acceptor 有 N 个，Proposer 提出的 value 必须获得超过半数(N/2+1)的 Acceptor批准后才能通过。Acceptor 之间完全对等独立。
3. Learner：提议学习者。上面提到只要超过半数accpetor通过即可获得通过，那么learner角色的目的就是把通过的确定性取值同步给其他未确定的Acceptor。

## 协议过程

一句话说明是：

> proposer将发起提案（value）给所有accpetor，超过半数accpetor获得批准后，proposer将提案写入accpetor内，最终所有accpetor获得一致性的确定性取值，且后续不允许再修改。

**协议分为两大阶段，每个阶段又分为A/B两小步骤：**

1. 准备阶段（占坑阶段）

2. 1. 第一阶段A：Proposer选择一个提议编号n，向所有的Acceptor广播Prepare（n）请求。
   2. 第一阶段B：Acceptor接收到Prepare（n）请求，若提议编号n比之前接收的Prepare请求都要大，则承诺将不会接收提议编号比n小的提议，并且带上之前Accept的提议中编号小于n的最大的提议，否则不予理会。

3. 接受阶段（提交阶段）

4. 1. 第二阶段A：整个协议最为关键的点：Proposer得到了Acceptor响应

   2. 1. 如果未超过半数accpetor响应，直接转为提议失败；

      2. 如果超过多数Acceptor的承诺，又分为不同情况：

      3. 1. 如果所有Acceptor都未接收过值（都为null），那么向所有的Acceptor发起自己的值和提议编号n，记住，一定是所有Acceptor都没接受过值；
         2. 如果有部分Acceptor接收过值，那么从所有接受过的值中**选择对应的提议编号最大的**作为提议的值，提议编号仍然为n。但此时Proposer就不能提议自己的值，只能信任Acceptor通过的值，维护一但获得确定性取值就不能更改原则；

   3. 第二阶段B：Acceptor接收到提议后，如果该提议版本号不等于自身保存记录的版本号（第一阶段记录的），不接受该请求，相等则写入本地。



整个paxos协议过程看似复杂难懂，但**只要把握和理解这两点就基本理解了paxos的精髓**：

1. *理解第一阶段accpetor的处理流程*：如果本地已经写入了，不再接受和同意后面的所有请求，并返回本地写入的值；如果本地未写入，则本地记录该请求的版本号，并不再接受其他版本号的请求，简单来说只信任最后一次提交的版本号的请求，使其他版本号写入失效；

2. *理解第二阶段proposer的处理流程*：未超过半数accpetor响应，提议失败；超过半数的accpetor值都为空才提交**自身要写入的值**，否则选择非空值里**版本号最大的值**提交，最大的区别在于是提交的值是自身的还是使用以前提交的。

   ​



## 形象生动的例子

![](https://ws2.sinaimg.cn/large/006tKfTcgy1fq9mqnxvaoj31kw23be81.jpg)

![](https://ws2.sinaimg.cn/large/006tKfTcgy1fq9mrnmg4uj31kw20nb29.jpg)

![](https://ws2.sinaimg.cn/large/006tKfTcgy1fq9msmx9v0j31kw241e81.jpg)

![](https://ws2.sinaimg.cn/large/006tKfTcgy1fq9mwcya98j31kw23tb29.jpg)



9）到这里，“提议者1”已经得到两个接受者的赞同，已经得到了多数“接受者”的赞同。于是“提议者1”确定1号提议最终通过。应该还有一个learn角色，用于感知value最终是否被大多数acceptor认可，如果已经超过半数认可则value被定下来，并通知所有actor关闭本次更新流程。更新应该是连续的，每次更新都会有一个编号。实际应用过程中还需要对更新编号进行处理，避免老的数据残留。



## 小结

准备阶段中,接受者会总是接受更大的提议编号,那么在提交阶段,过半接受者接受的提议编号对应的提议会被确定为最终的值

但是也不是提议编号越大,提议获得通过的几率就越大,就像上面的例子中的一样,实际情况中存在时间先后,所以提议编号小也是有可能被过半的接受的(条件是提议编号小的提议在提议编号大的提议之前,先"占领"过半的acceptor)