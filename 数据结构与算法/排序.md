# 堆排序

```java
public class HeapSort { 
 
  public static void main(String[] args) { 
    int[] arr = { 50, 10, 90, 30, 70, 40, 80, 60, 20 }; 
    System.out.println("排序之前："); 
    for (int i = 0; i < arr.length; i++) { 
      System.out.print(arr[i] + " "); 
    } 
 
    // 堆排序 
    heapSort(arr); 
 
    System.out.println(); 
    System.out.println("排序之后："); 
    for (int i = 0; i < arr.length; i++) { 
      System.out.print(arr[i] + " "); 
    } 
  } 
 
  /** 
   * 堆排序 
   */ 
  private static void heapSort(int[] arr) {  
    // 将待排序的序列构建成一个大顶堆 
    for (int i = arr.length / 2; i >= 0; i--){  
      heapAdjust(arr, i, arr.length);  
    } 
     
    // 逐步将每个最大值的根节点与末尾元素交换，并且再调整二叉树，使其成为大顶堆 
    for (int i = arr.length - 1; i > 0; i--) {  
      swap(arr, 0, i); // 将堆顶记录和当前未经排序子序列的最后一个记录交换 
      heapAdjust(arr, 0, i); // 交换之后，需要重新检查堆是否符合大顶堆，不符合则要调整 
    } 
  } 
 
  /** 
   * 构建堆的过程 
   * @param arr 需要排序的数组 
   * @param i 需要构建堆的根节点的序号 
   * @param n 数组的长度 
   */ 
  private static void heapAdjust(int[] arr, int i, int n) { 
    int child; 
    int father;  
    for (father = arr[i]; leftChild(i) < n; i = child) { 
      child = leftChild(i); 
       
      // 如果左子树小于右子树，则需要比较右子树和父节点 
      if (child != n - 1 && arr[child] < arr[child + 1]) { 
        child++; // 序号增1，指向右子树 
      } 
       
      // 如果父节点小于孩子结点
      if (father < arr[child]) { 
        arr[i] = arr[child]; 
      } else { 
        break; // 大顶堆结构未被破坏，不需要调整 
      } 
    } 
    arr[i] = father; 
  } 
 
  // 获取到左孩子结点 
  private static int leftChild(int i) { 
    return 2 * i + 1; 
  } 
   
  // 交换元素位置 
  private static void swap(int[] arr, int index1, int index2) { 
    int tmp = arr[index1]; 
    arr[index1] = arr[index2]; 
    arr[index2] = tmp; 
  } 
} 
```

### 坑点:

如果父节点小于孩子结点, 并不是交换,而是 把更大的子节点和较小的父节点 都赋值为  更大的子节点的值, 而不是"交换"





# 快速排序

```java

public class QuickSort {
	public static void main(String[] args) {
		int[] a = { 9, 3, 5, 1, 0, 8, 2, 4, 7, 6 };
		// 排序之前的序列
		print(a);
		// 调用快速排序方法
		quickSort(a, 0, a.length - 1);
		// 排完序之后输出数组验证是否正确排序
		print(a);
 
	}
 
	/**
	 * 实现一次划分的过程
	 * 
	 * @param a
	 *            数组元素数组a
	 * @param low
	 *            划分序列区间[low...high]
	 * @param high
	 * @return 返回枢纽元素的位置
	 */
	public static int FindPos(int[] a, int low, int high) {
		int pivot = a[low];// 使用a[low](第一个元素)作为枢纽元素
		while (low < high) {// 从两端交替向内扫描
			while (low < high && a[high] > pivot)
				high--;
			a[low] = a[high];// 将比pivot(枢纽值)小的元素向前移动
			while (low < high && a[low] < pivot)
				low++;
			a[high] = a[low];// 将比pivot(枢纽值)大的元素向后移动
		}// 终止while循环之后low和high一定是相等的
		a[low] = pivot;// 设置枢纽(中间剩余的那个元素)
		return low;// 返回枢纽元素位置，可以是high,但不能返回pivot,a[low],a[high]
	}
 
	// 在划分算法的基础上，快速排序算法的递归实现算法如下
	public static void quickSort(int[] a, int low, int high) {
		int pos;// 声明获取枢纽元素的位置变量
		if (low < high) {
			pos = FindPos(a, low, high);// 先对表进行划分：一分为二
			quickSort(a, low, pos - 1);// 对左边的表进行递归排序
			quickSort(a, pos + 1, high);// 对右边的表进行递归排序
		}
	}
 
	// 输出数组元素的方法
	public static void print(int[] a) {
		for (int i = 0; i < a.length; i++) {
			System.out.print(a[i] + "\t");
		}
		System.out.println();//换行
	}

```

### 坑点:

在一次FindPos中,pivot是永远不变的

```java
while (low < high && a[high] > pivot)
				high--;
			a[low] = a[high];// 将比pivot(枢纽值)小的元素向前移动
while (low < high && a[low] < pivot)
				low++;
			a[high] = a[low];
```

注意:a[low] = a[hign]  并不是"交换", 而只是赋值